---
title: "[FPGA] Alchitry au - "
date: 2025-01-23 22:46:00 +09:00
categories: FPGA
description: DDR3 메모리를 사용하여 
pin: true
use_math: true
---

## 1. DDR(Double Data Rate) 메모리

DDR 메모리는 동기식 DRAM의 일종으로 클럭 주파수를 기준으로 두배의 데이터를 전송할 수 있다.
Alchity Au 보드는 Artix-7 FPGA 칩을 사용한다. 이 Artix-7 FPGA는 내부 메모리 컨트롤러를 포함하고 있어, DDR3와 같은 메모리 모듈을 인터페이스할 수 있다. Vivado에서는 이를 활용하기 위해서 IP Catalog를 제공하지만 IP를 사용하기 위해서는 DDR3과 보드의 핀아웃(inout)에 대한 지식이 필요하다. 하지만 Alchitry lab을 사용하면 간단한 지식만으로도 조작이 가능하다. 

> IP(Interllectual Property) Catalog?    
> FPGA 설계를 쉽게 할 수 있도록 미리 정의해둔 하드웨어 모듈(IP)들의 라이브러리이다. 

### 1-1. DDR 메모리 추가하기

<img src="{{ site.baseurl }}/assets/img/post/FPGA/generate_core.png" alt="코어 생성하기" style="width: 70%">

먼저 Base Project 템플릿으로 새 프로젝트를 생성한다. 그리고 [Add Component] - [Generate MIG core (DDR)]를 통해 프로젝트에 Xilinx의 메모리 인터페이스를 세팅한다. 이 옵션은 alchitry au 보드를 사용할 때에만 활성화된다.

<img src="{{ site.baseurl }}/assets/img/post/FPGA/done_generate_core.png" alt="코어 생성 완료" style="width: 70%">

그러면 파일 트리에 mig_7series_0이 생긴 것을 확인할 수 있다. 이는 메모리 인터페이스를 추가하기 위한 필수 명령어들이 프로젝트에 추가되었음을 의미하며, 이 파일은 FPGA와 DDR3 메모리 모듈 사이의 연결을 정의한 verilog 파일이다.

이 파일을 직접 사용하는 것도 괜찮지만, 이를 상위 계층의 모듈로 한번 더 감싸 사용하는 것이 더욱 편리하다. 

[Add Component] - [Component Library] - [Memory] - [MIG Wrapper (DDR3)]를 추가한다. 그러면 두 개의 전역변수 구조가 정의된 `mig_wrapper.luc`가 생성된다. 
또, 내부에 `ddr3_`로 시작하는 수많은 input과 output이 정의되어 있는데 이는 모두 DDR3 칩과 연결하기 위해 필요한 신호들이다. 이 신호들의 이름은 mig_7series_0 core에 실제로 있는 이름을 사용하기 때문에 이름을 수정하면 안된다.  

이제 아래 코드로 `alchitry_top.luc`를 작성하자. 마찬가지로 이름을 마음대로 수정하면 안된다. 

<details>
<summary>alchitry_top.luc 전체 코드</summary>

```
module alchitry_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led[8],          // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    /* DDR3 Connections */
    inout ddr3_dq[16],
    inout ddr3_dqs_n[2],
    inout ddr3_dqs_p[2],
    output ddr3_addr[14],
    output ddr3_ba[3],
    output ddr3_ras_n,
    output ddr3_cas_n,
    output ddr3_we_n,
    output ddr3_reset_n,
    output ddr3_ck_p,
    output ddr3_ck_n,
    output ddr3_cke,
    output ddr3_cs_n,
    output ddr3_dm[2],
    output ddr3_odt
) {
    // clock generator takes 100MHz in and creates 100MHz + 200MHz
    clk_wiz_0 clk_wiz(.resetn(rst_n), .clk_in(clk))

    // DDR3 Interface - connect inouts directly
    mig_wrapper mig (
        .ddr3_dq(ddr3_dq),
        .ddr3_dqs_n(ddr3_dqs_n),
        .ddr3_dqs_p(ddr3_dqs_p),
        .sys_rst(!clk_wiz.locked), // reset when clk_wiz isn't locked
        .sys_clk(clk_wiz.clk_out1), // 100MHz clock
        .clk_ref(clk_wiz.clk_out2)  // 200MHz clock
    )

    sig rst = mig.sync_rst // use the reset signal from the mig core

    always {
        /* DDR3 Connections */
        ddr3_addr = mig.ddr3_addr
        ddr3_ba = mig.ddr3_ba
        ddr3_ras_n = mig.ddr3_ras_n
        ddr3_cas_n = mig.ddr3_cas_n
        ddr3_we_n = mig.ddr3_we_n
        ddr3_reset_n = mig.ddr3_reset_n
        ddr3_ck_p = mig.ddr3_ck_p
        ddr3_ck_n = mig.ddr3_ck_n
        ddr3_cke = mig.ddr3_cke
        ddr3_cs_n = mig.ddr3_cs_n
        ddr3_dm = mig.ddr3_dm
        ddr3_odt = mig.ddr3_odt

        // default values
        mig.mem_in = <Memory.in>(
            .enable(0), 
            .cmd(3bx),
            .addr(28bx),
            .wr_data(128bx),
            .wr_mask(0),
            .wr_enable(0)
        )

        led = 8h00              // turn LEDs off

        usb_tx = usb_rx         // echo the serial data
    }
}
```
</details>

### 1-2. 클록 세팅하기

메모리 인터페이스는 100MHz, 200MHz 클록 필요하다. 하지만 au보드가 100MHz를 기본으로 가지고 있으므로 200MHz만 생성하면 된다. `clk_wiz_0`은 클럭 생성기로 100MHz의 클럭을 입력으로 받아서 100MHz와 200MHz를 출력한다. 

클록을 생성하기 위해서 [Add Component] - [Vivado IP Catalog]를 클릭해서 IP Catalog를 연다. 

<img src="{{ site.baseurl }}/assets/img/post/FPGA/ip_catalog.png" alt="ip 카탈로그" style="width: 70%">

이후 창 오른쪽에서 [IP Catalog] - [FPGA Features and Design]- [Cloking] -[Cloking Wizard]를 더블 클릭하여 새 창을 연다. 

[Cloking Options]에서 Input clock Information의 Primary의 이름을 `clk_in`으로 수정해준다.

<img src="{{ site.baseurl }}/assets/img/post/FPGA/add_output_clock.png" alt="출력 클록 추가" style="width: 70%">

또, [Output Clocks]를 클릭해 `clk_out2`를 200MHz로 추가해주고 reset의 타입을 'Active low'로 수정한다. Ok를 눌러 창을 닫은 후, 이후 열리는 창에서도 generate를 선택해준다. 

<img src="{{ site.baseurl }}/assets/img/post/FPGA/clock_added.png" alt="클록 추가" style="width: 70%">

그러면 위 이미지처럼 clk_wiz_0가 추가된다. 그리고 vivado 창을 닫고 alchitry lab을 보면 core 아래에 clk_wiz_0 파일이 추가된 것을 확인할 수 있다. 

### 1-3. 명령 인터페이스 사용하기

core를 사용하기 위해서는 `mig_wrapper` 모듈의 전역 구조 변수만을 고려하면 된다. 
in에서 `cmd`(실제는 app_cmd를 의미)는 3비트의 크기를 가지지만 실제로 쓰이는 값음 0(쓰기), 1(읽기) 뿐이다. 

쓰기는 FIFO인데, FIFO에 공간이 있으면 `wr_rdy`가 1로 활성화되며, 이때 `we_enable`을 1로 설정하여, `wr_data`에 적힌 데이터를 버퍼에 기록한다. 
이때 `wr_mask`의 값에 따라 `wr_data`에서 해당되는 바이트만큼을 무시한다. 
예를 들어, `wr_mask`를  `16hFFFF`로 설정하면 `wr_data`에 저장된 16바이트를 모두 무시하여 아무런 데이터도 전송되지 않는다.

읽기는 새 데이터가 준비되면 `rd_valid`를 1로 설정하고 읽은 데이터는 `rd_data`에 저장된다. 

명령 인터페이스를 사용하기 위해서는 `rdy`를 1로 설정하고 이후 `cmd`를 0(쓰기) 또는 1(읽기)로, 관련 주소를 `addr`에 입력하고, `enable`를 1로 한다. 

이처럼 쓰기 인터페이스, 읽기 인터페이스, 명령 인터페이스가 각각 독립적으로 존재하는 이유는 효율성 때문이다. 읽기가 수행되는 동안 쓰기가 실행될 수도 있고 읽을 데이터가 준비되기 전에 다른 명령어를 받을 수도 있다. 여러 명령이 수행되는 동안 또 다른 명령어들이 생성될 수 있지만, 이들은 입력되어진 순서대로 명령어들을 수행한다. 

## 2. 읽고 쓰기 예제




